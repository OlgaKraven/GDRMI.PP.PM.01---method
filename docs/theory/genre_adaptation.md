# 1. Теория. 3. Жанровая адаптация ИС сопровождения игрового продукта  

Жанровая адаптация — это **проектирование надстройки над ядром**. Ядро (Users/Sessions/Events/Progress/Stats/Leaderboard) отвечает за общие механизмы сопровождения, а жанровый модуль отвечает за **доменные правила** конкретной игры: экономика, бои, сюжет, обучение, выживание.

Ключевое правило архитектора:

> **Ядро не ломаем.**
> Любой жанр добавляет *свои таблицы*, которые привязываются к `users` и к центральной “единице игрового процесса” (`match/run/episode/cycle`).
> Все важные действия логируются через `game_events` (универсальная шина событий).

---

## 3.1. Шаблон расширения под жанр (как мыслить системно)

Перед добавлением таблиц студент отвечает на 5 вопросов (так меньше ошибок):

### 3.1.1. Какая “единица игрового процесса”?

Это объект, вокруг которого строится основная логика:

* **match** — короткая автономная сессия с результатом (Shooter/TD/Strategy)
* **run** — попытка “выжить/пройти”, часто с перманентной смертью (Survival/Roguelike)
* **episode/chapter** — продвижение по истории (Visual Novel)
* **cycle/day/tick** — экономика по периодам (Economic)
* **session + offline period** — доход/прогресс во времени (Idle)

**Почему важно выбрать “единицу”:**
без неё вы не сможете:

* правильно фиксировать результат,
* считать метрики (winrate, completion),
* делать транзакции “итог → награда → прогресс”.

---

### 3.1.2. Что сервер подтверждает как “истину”?

Сервер подтверждает то, что влияет на:

* **экономику** (валюта/ресурсы/покупки/апгрейды),
* **прогресс** (уровни, главы, открытые зоны),
* **соревнование** (score/win/lose/MMR),
* **античит** (пределы значений, монотонность времени, лимиты операций).

**Почему это не оставляют клиенту:**
клиент можно модифицировать; если доверять ему валюту/результаты — игрок “нарисует” себе прогресс.

---

### 3.1.3. Какие метрики нужны?

Две группы:

**Операционные (для UI игрока)**

* то, что показывается в профиле/истории матчей/экран статистики.

**Продуктовые (для аналитики)**

* retention, churn, баланс, монетизация, точки “отвала”.

---

### 3.1.4. Какие данные “снимком” и какие “журналом”?

* **Журнал (log)**: `game_events` и жанровые журналы (actions, transactions) — нужны для расследований.
* **Снимок (state)**: `player_progress`, `user_story_state`, `company_resources` — нужно для быстрых загрузок.

**Почему разделяем:**
журнал растёт, снимок позволяет быстро работать без пересчётов.

---

### 3.1.5. Где нужны транзакции?

Транзакции обязательны там, где в одном действии меняются:

* факт результата (match_finish/run_end),
* награда,
* прогресс,
* статистика,
* лидерборд.

Если не сделать транзакцию, появится “полу-записанный успех”.

---

### 3.1.6. Универсальный паттерн схемы жанра 

Почти любой жанр укладывается в конструкцию:

* `X` — центральная сущность процесса (`matches`, `runs`, `episodes`, `cycles`)
* `X_events` / `X_actions` — журнал действий внутри процесса
* `X_result` — итог процесса (score/win/duration/ending)
* `user_X_state` — “состояние игрока в жанре” (если нужно)

И всё это:

* привязано к `users`
* и логируется в `game_events` ключевыми событиями

---

## 3.2. Экономический симулятор (Economic)

### 3.2.1. Единица процесса

**Цикл экономики**: `day/tick/cycle`.
В экономике “матча” обычно нет, зато есть периодическое производство/рынок.

### 3.2.2. Добавляемые сущности (таблицы) — с логикой зачем

* `companies` — профиль бизнеса игрока (уровень компании, специализация)
* `assets` — активы (заводы, офисы, техника) + уровень апгрейда
* `resources` — справочник ресурсов (дерево, металл, энергия)
* `company_resources` — остатки (склад): **снимок** ресурсов
* `production_jobs` — задания производства (что производим, сколько, когда готово)
* `contracts` — сделки (поставки/заказы) + состояние
* `market_prices` — цены по времени/региону (если есть рынок)
* `transactions` — финансовый журнал (приход/расход)

**Почему `transactions` обязательно:**
без журнала финансов вы не докажете, почему “пропали деньги”.

### 3.2.3. Сервер подтверждает как истину

* списания и начисления денег/ресурсов (по правилам, не по клиенту),
* выполнение производства и выпуск продукции,
* завершение контрактов,
* рыночные цены (если общий рынок).

### 3.2.4. Метрики

Операционные:

* cash balance, inventory by resource
* profit/day, revenue/day
* production throughput (единиц/час)

Продуктовые:

* ROI апгрейдов
* bottlenecks: где дефицит ресурсов
* ценовая эластичность: как игроки реагируют на рынок
* прогресс “уровня компании”

### 3.2.5. Примеры ключевых событий (game_events)

* `production_start`, `production_finish`
* `contract_accept`, `contract_complete`
* `transaction` (или `currency_change`)

Пример payload:

```json
{
  "eventType": "contract_complete",
  "payload": {
    "contractId": 501,
    "reward": { "money": 1200 },
    "spent": { "wood": 20, "metal": 10 }
  }
}
```

---

## 3.3. Idle / Clicker

### 3.3.1. Единица процесса

**Сессия + офлайн-период**.
Главная проблема жанра — честно считать время и доход.

#### 3.3.2. Добавляемые сущности — с объяснением

* `generators` — справочник генераторов дохода (шахта, ферма)
* `user_generators` — уровень/количество генераторов игрока (**снимок**)
* `upgrades` + `user_upgrades` — перки, влияющие на формулы дохода
* `boosters` — временные усилители
* `offline_income` — факт выдачи офлайн-дохода (чтобы не получить дважды)

**Почему `offline_income` обязателен:**
иначе игрок сможет повторно “забрать офлайн-награду”.

#### 3.3.3. Сервер подтверждает

* серверное время последней активности,
* формулу офлайн-дохода,
* списание валюты за апгрейды,
* лимиты бустеров.

#### 3.3.4. Метрики

Операционные:

* income_per_second
* offline_income_claimed
* generator_distribution (какие уровни у игроков)

Продуктовые:

* progression curve (скорость роста)
* retention vs offline reward
* pay conversion на ускорители

#### 3.3.5. События

* `offline_claim`
* `generator_upgrade`
* `booster_activate`

---

## 3.4. RPG

### 3.4.1. Единица процесса

**Персонаж + активности** (квесты/бои/данжи).

### 3.4.2. Добавляемые сущности — что за что отвечает

* `characters` — если персонажей несколько (класс, уровень)
* `character_stats` — параметры (STR/DEX/HP/MP)
* `items` — справочник предметов
* `inventory_items` — инвентарь (item_id, qty, bind, durability)
* `equipment_slots` / `character_equipment` — экипировка
* `skills` / `character_skills` — навыки
* `quests` / `quest_steps` / `user_quests` — прогресс квестов
* `loot_drops` — факт выдачи лута (для античита и расследований)

**Почему `loot_drops` часто нужен:**
иначе “я выбил легендарку, но пропала” невозможно расследовать.

### 3.4.3. Сервер подтверждает

* выдачу предметов (drop) и их редкость,
* завершение квестов и награды,
* прокачку навыков,
* операции инвентаря (нельзя “дублировать” предмет).

### 3.4.4. Метрики

Операционные:

* прогресс по квестам, сила персонажа (power)
* rarity distribution

Продуктовые:

* quest funnel (где застревают)
* баланс предметов/билдов
* темп прокачки по уровням

### 3.4.5. События

* `quest_complete`
* `item_grant`, `item_equip`
* `skill_upgrade`

---

## 3.5. Strategy / Tower Defense

### 3.5.1. Единица процесса

**Матч/забег + волны**.

### 3.5.2. Добавляемые сущности — минимальный “боевой модуль”

* `matches` — матч (mode/map/season/status)
* `match_waves` — волны (wave_number, enemies_killed, base_hp_left)
* `towers/buildings` — справочник
* `player_buildings` — постоянный прогресс башен игрока (если есть)
* `match_build_actions` — журнал действий (build/upgrade/sell)
* `battle_results` — итог (is_win, score, duration, wave_reached)

**Почему `match_build_actions` полезен:**
это главный источник баланса и расследований “как игрок прошёл волну”.

### 3.5.3. Сервер подтверждает

* экономику строительства (хватало ресурсов),
* валидность волнового прогресса,
* расчёт наград,
* попадание в лидерборд.

### 3.5.4. Метрики

Операционные:

* winrate, wave_reached, avg_duration
* base_hp_left trend

Продуктовые:

* difficulty funnel по волнам
* эффективность башен (pick rate vs win)
* баланс карт

### 3.5.5. События

* `match_start`, `match_finish`
* `build`, `upgrade`
* `wave_end`

---

## 3.6. Shooter / Action

### 3.6.1. Единица процесса

**Матч**, иногда **раунды**.

### 3.6.2. Добавляемые сущности — “телеметрия боя”

* `matches` / `rounds`
* `weapons`
* `player_loadouts`
* `match_kills` / `match_deaths` / `assists`
* `shots_agg` (shots_fired, shots_hit) — лучше агрегатом, а не каждый выстрел
* `damage_events` (опционально для расследований)

**Почему “выстрелы лучше агрегатом”:**
логировать каждый выстрел = огромный объём events → БД “умирает”.

### 3.6.3. Сервер подтверждает

* результат матча,
* античит пороги (accuracy, fire rate),
* рейтинг/ранг,
* награды.

### 3.6.4. Метрики

Операционные:

* K/D, accuracy, HS rate

Продуктовые:

* weapon balance
* подозрительность профилей
* удержание по режимам

### 3.6.5. События

* `match_finish`
* `kill` (агрегировать: кто/чем/где)
* `shots_summary`

---

## 3.7. Visual Novel

### 3.7.1. Единица процесса

**Эпизод/глава/узел истории**.

### 3.7.2. Добавляемые сущности — “состояние истории”

* `story_nodes` — узлы сюжета
* `choices` — варианты выбора
* `user_story_state` — текущий узел + флаги веток (**снимок**)
* `user_choices` — факты выборов (**журнал**)
* `endings` + `user_endings` — концовки

**Почему нужен и snapshot, и journal:**

* snapshot быстро грузит “где я остановился”
* journal объясняет “какие выборы я делал” (и помогает метрикам).

### 3.7.3. Сервер подтверждает

* факты выбора,
* открытие концовок,
* прогресс на разных устройствах.

### 3.7.4. Метрики

Операционные:

* current node/chapter
* endings unlocked

Продуктовые:

* distribution choices
* chapter funnel (где бросают)
* completion rate

### 3.7.5. События

* `choice_made`
* `chapter_complete`
* `ending_unlocked`

---

## 3.8. Educational Game

### 3.8.1. Единица процесса

**Урок/модуль + попытка**.

### 3.8.2. Добавляемые сущности — “обучающий контур”

* `lessons/modules`
* `tasks/questions`
* `attempts` — попытки (start_at, end_at, score)
* `answers` (опционально)
* `mastery` — уровень освоения
* `certificates` (если выдаются)

**Почему attempts обязательно:**
это базовый аудит: кто когда решал и какой результат.

### 3.8.3. Сервер подтверждает

* оценивание (не доверять клиенту “я решил на 100”),
* лимиты попыток,
* прогресс mastery.

### 3.8.4. Метрики

Операционные:

* score per lesson
* time per task

Продуктовые:

* error frequency by topic
* learning curve
* dropout points

### 3.8.5. События

* `attempt_start`, `attempt_finish`
* `task_failed` (с типом ошибки)
* `module_complete`

---

## 3.9. Survival

### 3.9.1. Единица процесса

**Run / survival_session** (забег/жизнь).

### 3.9.2. Добавляемые сущности — “контур выживания”

* `runs` — забеги (start/end/status)
* `run_states` (опционально снапшоты состояния)
* `resources_collected`
* `crafting_recipes` + `crafted_items`
* `world_events`
* `death_events` (причина смерти)

**Почему run_states опционально:**
нужен, если игра поддерживает:

* resume,
* сохранение состояния в середине,
* синхронизацию между устройствами.

### 3.9.3. Сервер подтверждает

* время выживания,
* крафт и списание,
* причину смерти,
* награды/штрафы.

### 3.9.4. Метрики

Операционные:

* survival_time
* resources/min

Продуктовые:

* death reasons distribution
* difficulty spikes
* retention vs run length

### 3.9.5. События

* `run_start`, `run_end`
* `craft_item`
* `death`
