# 1. Теория. 4. Реализация backend’а ИС сопровождения игрового продукта  

Цель раздела — не просто “собрать сервер”, а **научиться проектировать backend как промышленный модуль**, где:

* входные данные **нельзя** доверять (клиент — не источник истины);
* архитектура **масштабируется** (stateless);
* ошибки **предсказуемы** (единый формат);
* данные **целостны** (транзакции + ограничения);
* поведение **наблюдаемо** (логирование + requestId).

---

## 4.0. Почему backend игры — это не просто CRUD

Игровой backend решает 3 класса задач:

1. **Геймплейные правила**: кто что может сделать, сколько начислить, что разрешить.
2. **Целостность**: прогресс, валюта, результаты матчей не должны расходиться.
3. **Наблюдаемость и расследование**: если игрок пишет “у меня пропала валюта” или “меня банят ошибочно”, нужны события, логи, корреляция.

Поэтому “быстро накидать эндпоинты” не подходит — нужна архитектура.

---

## 4.1. Минимальная рабочая архитектура backend (MVP) — почему именно такой конвейер

**Структура потока запроса:**

```
Request
  → requestId + logging
  → JWT auth
  → Validation
  → Controller
  → Service (business + transactions)
  → Repository (SQL)
  → Response (JSON)
Error → errorHandler → JSON + logging
```

### Почему не “контроллер сразу в БД”?

Потому что в играх неизбежно появляются:

* транзакции на несколько таблиц;
* правила античита;
* расчёт наград;
* обновление статистики + лидерборда.

Если всё сделать в контроллере, то:

* код невозможно тестировать без HTTP;
* невозможно переиспользовать логику (например, “finish match” из двух разных эндпоинтов);
* добавление новых жанровых модулей приводит к хаосу.

---

### 4.1.1. Пример “как запрос проходит по слоям” (POST `/event`)

**1) RequestId + logging**
Появляется `requestId=abc123` и логируется факт запроса.

**2) JWT auth**
Из токена достаём `userId=15`, `roles=['player']`.

**3) Validation**
Проверяем, что:

* `eventType` строка из whitelist
* `payload` объект
* `sessionId` число или null

Если не так — **400** без похода в БД.

**4) Controller**
Только переводит HTTP → команду:

* взять body
* добавить userId
* вызвать service

**5) Service**
Решает бизнес:

* можно ли этому user отправлять такие события?
* надо ли обновить прогресс/статистику?
* применить лимиты частоты событий
* записать событие

**6) Repository**
Выполняет SQL `INSERT INTO game_events ...`.

**7) Response**
Возвращает `{ ok:true }`.

---

## 4.2. Структура проекта (обязательная) — зачем такое разделение

```
/src
  /config
  /models
  /repositories
  /services
  /controllers
  /middleware
  /routes
  /docs
  app.js
  server.js
```

### Почему `controllers` должны быть “тонкими”

Контроллер — это **транспортный слой**. Он обязан:

* читать запрос,
* вызывать бизнес-логику,
* формировать ответ.

Если в контроллере окажутся правила:

* вы получите дублирование (progress обновляется в 3 местах);
* вы не сможете повторно использовать “finish match” из админки;
* unit-тесты превратятся в интеграционные (долго и больно).

### Почему `services` — это центр системы

Потому что сервисы:

* содержат правила (начисления, ограничения, античит-пороги);
* управляют транзакциями;
* вызывают несколько репозиториев.

Именно сервисы — то, что вы **будете расширять под жанры**.

### Почему `repositories` — только SQL

Чтобы было правило:

> если меняется БД/индексы/запросы — меняется репозиторий, а не бизнес-логика.

Это даёт:

* заменяемость (MySQL → Postgres, если надо);
* читаемость;
* возможность тестировать сервисы, подменяя репозитории.

---

## 4.3. Теория “коротко, но глубже”: почему так, а не иначе

### 4.3.1. Stateless REST: почему нельзя хранить состояние клиента в памяти сервера

**Плохой вариант:**
сервер хранит “текущий матч” пользователя в памяти процесса.

Что ломается:

* при перезапуске процесса всё “теряется”;
* при двух инстансах серверов разные запросы попадут на разные инстансы и “память не совпадёт”;
* скейлинг невозможен без sticky sessions.

**Правильный вариант:**

* состояние игрока — в БД (`matches`, `player_progress`);
* запросы несут JWT + нужные данные;
* сервер можно масштабировать вширь.

---

### 4.3.2. JSON как контракт: почему не “просто строки” и не “XML”

JSON:

* нативен для Web (`fetch`) и удобен для Unity (JsonUtility/Newtonsoft);
* хорошо описывается OpenAPI/Swagger;
* позволяет хранить `payload` событий гибко.

**Важно:** JSON не отменяет типизацию — поэтому нужна **валидация схемой**, иначе в БД окажется мусор.

---

### 4.3.3. JWT: почему токен, а не серверная сессия

JWT позволяет:

* stateless авторизацию (сервер не хранит session store);
* быстрые проверки на каждом запросе;
* простую интеграцию с Unity/Web/Mobile.

**Почему токен должен быть короткоживущим:**

* если токен “вечный”, украли → всё, аккаунт скомпрометирован;
* короткий срок + refresh (если реализуете) — безопаснее.

**Почему роли в токене допустимы:**

* это ускоряет проверки (RBAC);
* но бан/отключение пользователя всё равно проверяется в БД (is_banned), иначе токен “обходит бан”.

---

## 4.4. Единый формат ответов и ошибок — зачем это в реальной разработке

Если ошибки у разных эндпоинтов разные:

* клиент не может предсказуемо обработать (Unity начнёт “падать” на неожиданных полях);
* тестирование превращается в ад;
* логирование не связывается с проблемой.

### Успех

```json
{ "ok": true, "data": { } }
```

### Ошибка

```json
{
  "ok": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Field level must be >= 1",
    "requestId": "req_01HF..."
  }
}
```

### Почему нужен requestId

Сценарий из практики:

* студент тестирует `/progress`, получает ошибку “500”.
* по requestId вы в логах находите:

  * SQL ошибку,
  * userId,
  * входные параметры,
  * stack trace.

Без requestId это превращается в “не воспроизводится”.

---

## 4.5. Middleware (обязательные) — почему именно они и где примеры

### 4.5.1. requestId.middleware — пример

**Задача:** корреляция логов и ответа.

Пример поведения:

* Header ответа: `X-Request-Id: req_abc123`
* Лог: `req_abc123 POST /event 200 12ms user=15`

---

### 4.5.2. logger.middleware — что логировать и чего нельзя

Логируем:

* метод, путь, статус, duration
* requestId
* userId (если есть)
* ошибки

**Нельзя логировать:**

* пароль
* полный JWT
* платежные данные

Пример строки лога:

```
req_abc123 user=15 POST /progress 200 18ms
```

---

### 4.5.3. authJwt.middleware — пример заголовка и результата

Запрос клиента:

```http
GET /profile
Authorization: Bearer <JWT>
```

После middleware:

```js
req.user = { id: 15, roles: ["player"] }
```

Почему это удобно:

* контроллеры не “парсят” JWT сами;
* любая ошибка авторизации одинакова (401).

---

### 4.5.4. validate.middleware — почему валидация до БД

Если валидации нет:

* в БД попадут `level = -999`;
* статистика/лидерборды сломаются;
* античит невозможен.

Пример “схемы” для `/event` (концептуально):

* `eventType`: string enum
* `sessionId`: number|null
* `payload`: object

---

### 4.5.5. rateLimit.middleware — зачем в играх обязательно

Игровой клиент может отправлять события очень часто.
Если игрок (или бот) отправляет 500 req/s:

* сервер ложится;
* БД переполняется;
* у вас DoS своими руками.

Поэтому минимум:

* `/login` — ограничить попытки (brute force)
* `/event` — ограничить частоту событий
* `/progress` — ограничить апдейты прогресса

---

### 4.5.6. error.middleware — почему единый обработчик лучше “try/catch везде”

Если try/catch в каждом контроллере:

* часть ошибок забывают обработать;
* ответы становятся разными;
* stack trace теряется.

Единый обработчик:

* перехватит любое исключение;
* вернёт одинаковый JSON;
* залогирует.

---

## 4.6. Слои backend: что в каком файле (с примерами “как должно выглядеть”)

Ниже примеры **на уровне структуры кода** (минимальные, чтобы студент понял идею).

### 4.6.1. Controller: тонкий слой (пример `/progress`)

```js
// progress.controller.js (идеология)
async function postProgress(req, res, next) {
  try {
    const userId = req.user.id;
    const dto = req.body;              // уже провалидирован middleware
    const result = await progressService.updateProgress(userId, dto);
    res.json({ ok: true, data: result });
  } catch (e) { next(e); }
}
```

**Почему так:** контроллер не знает про SQL и транзакции.

---

### 4.6.2. Service: бизнес-правила + транзакции

```js
// progress.service.js (идеология)
async function updateProgress(userId, dto) {
  // бизнес-правила: диапазоны, античит-пороги, согласованность
  // транзакция: progress + event log + stats update
  return db.transaction(async (tx) => {
    await progressRepo.upsert(tx, userId, dto);
    await eventRepo.insert(tx, userId, null, "progress_update", dto);
    await statsRepo.incrementDaily(tx, userId, { events: 1 });
    return await progressRepo.getByUserId(tx, userId);
  });
}
```

**Почему так:** если записали прогресс, но не записали событие — расследование будет невозможным. Транзакция решает.

---

### 4.6.3. Repository: только SQL

```js
// progress.repo.js (идеология)
async function upsert(tx, userId, dto) {
  // INSERT ... ON DUPLICATE KEY UPDATE
}
```

**Почему так:** репозиторий не решает “можно/нельзя”, он выполняет запрос.

---

## 4.7. Реализация ключевых модулей по endpoints (с примерами запросов/ответов)

### 4.7.1. POST `/register`

**Почему нужно назначать роль сразу:** иначе пользователь “неизвестный” и доступы разъедутся.

**Request**

```json
{ "email": "a@b.com", "password": "12345678", "nickname": "Player1" }
```

**Response 201**

```json
{ "ok": true, "data": { "userId": 15 } }
```

---

### 4.7.2. POST `/login`

**Почему проверяем ban на login:** иначе забаненный пользователь продолжит пользоваться токеном.

**Request**

```json
{ "email": "a@b.com", "password": "12345678" }
```

**Response 200**

```json
{
  "ok": true,
  "data": {
    "accessToken": "<JWT>",
    "tokenType": "Bearer",
    "expiresInSeconds": 3600
  }
}
```

---

### 4.7.3. GET `/profile`

**Почему профиль собирается сервисом, а не одним SELECT:** потому что это “витрина” из нескольких источников (users + progress + leaderboard snapshot).

**Response**

```json
{
  "ok": true,
  "data": {
    "user": { "id": 15, "email": "a@b.com", "nickname": "Player1" },
    "progress": { "level": 6, "xp": 2450, "softCurrency": 1200, "hardCurrency": 10 }
  }
}
```

---

### 4.7.4. POST `/event`

**Почему whitelist event_type:** иначе игрок сможет отправить “admin_grant_currency”.

**Request**

```json
{
  "sessionId": 991,
  "eventType": "match_finish",
  "payload": { "isWin": true, "score": 12450, "durationSeconds": 410 }
}
```

**Response**

```json
{ "ok": true, "data": { "accepted": true } }
```

---

### 4.7.5. POST `/progress`

**Почему нельзя принимать прогресс “как есть”:** игрок может прислать `hard_currency=999999`.

Поэтому:

* сервер принимает как “заявку”
* режет/проверяет по правилам (античит)

**Request**

```json
{ "level": 6, "xp": 2450, "softCurrency": 1200, "hardCurrency": 10 }
```

---

### 4.7.6. GET `/leaderboard`

**Почему leaderboard отдельная таблица:** иначе придётся сканировать events или stats каждый раз.

**Response**

```json
{
  "ok": true,
  "data": {
    "boardCode": "td_score",
    "season": 1,
    "top": [
      { "rank": 1, "userId": 15, "nickname": "Player1", "score": 12450 },
      { "rank": 2, "userId": 18, "nickname": "Player2", "score": 12010 }
    ]
  }
}
```

---

### 4.7.7. GET `/stats`

**Почему stats агрегируются:** потому что events растут быстро и дорого пересчитываются.

**Response**

```json
{
  "ok": true,
  "data": {
    "from": "2026-02-01",
    "to": "2026-02-26",
    "daily": [
      { "day": "2026-02-25", "sessions": 2, "playtimeSeconds": 1800, "wins": 1, "losses": 0 }
    ]
  }
}
```

---

## 4.8. Транзакции: где критично и что будет, если их не использовать

### 4.8.1. Типовой “критичный” кейс: завершение матча

На finish матча обычно меняются 4 области:

1. фиксируем результат (battle_results / event)
2. обновляем прогресс (xp/level/currency)
3. обновляем stats_daily
4. обновляем leaderboard (upsert)

**Если сделать без транзакции:**

* прогресс обновился, но лидерборд — нет → игрок недоволен
* лидерборд обновился, но прогресс — нет → “украли награду”
* записали результат дважды (повторный запрос) → накрутка

**С транзакцией:**

* либо всё вместе
* либо ничего

---
