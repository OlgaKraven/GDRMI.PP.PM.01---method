# 1. Теория. 5. API дизайн ИС сопровождения игрового продукта  

Цель раздела — научить студента проектировать API так, чтобы оно:

* было **предсказуемым** для Unity/Web/Mobile;
* работало как **stateless REST** (без серверных сессий);
* было **безопасным** (JWT + RBAC + валидация);
* было **удобным для тестирования** (Postman/Swagger);
* имело **единые ответы и ошибки** (контракт).

---

## 5.1. Принципы REST (что студент обязан соблюдать)

### 5.1.1. Ресурсный подход (почему “resource-first”)

REST — это про **ресурсы** (данные и их представления), а не про “команды”.

* **плохо:** `/doLogin`, `/updateProgressNow`, `/sendEventCommand`
* **хорошо:** `/auth/login`, `/progress`, `/events`

**Почему так правильно (инженерно):**

1. **Предсказуемость клиенту**
   Unity/Web/Mobile клиентам важно “угадывать” API:
   если всё построено как ресурсы — разработчик быстро находит нужный endpoint.

2. **Документация и тестирование проще**
   Swagger/OpenAPI “любит” ресурсный подход: схемы ресурсов, единые паттерны, меньше исключений.

3. **Эволюция без ломки**
   Командный подход часто приводит к хаосу: `/doX`, `/doX2`, `/doXNow`.
   Ресурсный подход позволяет расширять без переименований.

**Правило для студента:**
если endpoint звучит как глагол “сделай” — это сигнал, что вы проектируете команды, а не REST.

**Исключение (важное для игр):**
в играх есть “действия”, которые сложно выразить чистым CRUD (например, `match/finish`).
Тогда делаем “ресурс + подресурс-действие”, но в контролируемом виде:

* `POST /matches/{id}/finish`
* `POST /matches/{id}/events`

Это всё равно “ресурсно”, потому что базовый объект — `match`.

---

### 5.1.2. Stateless (почему “никаких server sessions”)

Каждый запрос несёт в себе всё необходимое:

* `Authorization: Bearer <JWT>`
* JSON body / query params

**Почему это критично именно в игровых системах:**

1. **Горизонтальное масштабирование**
   Если сервер хранит сессию в памяти, запрос №1 попал на инстанс A, запрос №2 — на B.
   B не знает “сессию” → ошибки, рассинхронизация.

2. **Повторы запросов (сетевые ретраи)**
   Мобильный интернет нестабилен: клиент повторяет запрос.
   Stateless API проще делает **idempotency / дедупликацию** (по requestId/eventId).

3. **Инфраструктура: балансировка, autoscaling**
   Stateless упрощает работу Load Balancer и запуск новых инстансов без прогрева “памяти сессий”.

**Практическое правило:**
состояние игрока хранится в БД (progress/stats), а не в памяти процесса.

---

### 5.1.3. Единый контракт JSON (включая ошибки)

API **всегда** отвечает JSON (даже на ошибках), чтобы Unity/Web/Mobile:

* не падали на HTML-странице ошибки,
* могли одинаково обработать любую ситуацию.

Рекомендуемый формат:

**Success**

```json
{ "ok": true, "data": {} }
```

**Error**

```json
{
  "ok": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Field level must be >= 1",
    "requestId": "req_..."
  }
}
```

**Почему это обязательно (а не “можно и так”)**:

1. **Клиентская обработка становится тривиальной**
   Один и тот же код обработки ошибок для всех endpoint’ов.

2. **requestId связывает клиента и сервер**
   Если студент потом добавит логирование, requestId позволит найти конкретный запрос в логах.

3. **Единый формат помогает тестированию**
   Postman коллекции/автотесты могут проверять `ok`, `error.code`, `error.requestId`.

**Правило безопасности:**
в `message` нельзя отдавать stack trace и SQL-ошибки в проде.
В лог — можно, клиенту — нет.

---

## 5.2. Именование endpoint’ов (правила)

### 5.2.1. Нотация URL

* только **lowercase**
* слова через `-` или `_` (лучше без подчеркиваний в URL)
* **существительные**: `/profile`, `/events`, `/leaderboard`
* версии API: `/api/v1/...` (если планируется развитие)

Пример:

* `/api/v1/auth/login`
* `/api/v1/profile`
* `/api/v1/progress`
* `/api/v1/events`

**Почему версионирование важно сразу (даже в учебном проекте):**

* вы сможете добавить поля/поведение без “ломания” клиентов;
* преподавателю проще принимать разные итерации проекта;
* студент видит практику индустрии.

**Рекомендованный нейминг:**

* `boardCode`, `season`, `limit` — в query
* `eventType`, `payload` — в body

---

### 5.2.2. Query params vs Body

* **GET**: фильтры в query
* **POST**: данные в body

Пример:

* `GET /leaderboard?boardCode=td_score&season=1&limit=100`
* `POST /events` — body содержит payload события

**Почему GET нельзя использовать для отправки событий:**

* GET может кэшироваться прокси/браузером;
* GET не предназначен для побочных эффектов;
* логика “GET записал данные” ломает дебаг, мониторинг и безопасность.

---

## 5.3. HTTP методы и коды (что и зачем)

### 5.3.1. Методы

* `POST` — создать / отправить событие / выполнить операцию записи
* `GET` — получить данные (без побочных эффектов)

*(Для MVP достаточно POST/GET. PUT/PATCH/DELETE можно позже.)*

**Почему в MVP реально достаточно:**

* студенту важнее освоить контур: auth → validation → service → db → response;
* PATCH/PUT добавляют сложность (частичные обновления, идемпотентность), это итерация №2.

---

### 5.3.2. Коды ответа (минимальный набор)

* `200 OK` — успешно
* `201 Created` — создан ресурс (register/match_start)
* `400 Bad Request` — валидация/поля неверны
* `401 Unauthorized` — нет JWT/невалиден
* `403 Forbidden` — нет прав / user banned
* `404 Not Found` — ресурс не найден
* `409 Conflict` — конфликт состояния (например, матч уже завершён)
* `429 Too Many Requests` — rate limit
* `500 Internal Server Error` — непредвиденная ошибка

**Почему важно соблюдать коды:**
клиенты (Unity/Web) могут автоматически отличать:

* “пользователь виноват” (400),
* “нет токена” (401),
* “прав нет” (403),
* “сервер упал” (500).

**Классика анти-паттерна студентов:**
“всегда 200 и внутри ok:false”.
Почему плохо: мониторинг и прокси видят “всё ок”, а система реально падает.

---

## 5.4. Минимальные endpoints (обязательные) — спецификация + примеры

Ниже — набор, который обязан быть у MVP.

---

### 5.4.1. `POST /register` — регистрация

**Назначение:** создать аккаунт, назначить роль `player`.

**Request**

```http
POST /api/v1/auth/register
Content-Type: application/json
```

```json
{
  "email": "player1@example.com",
  "password": "P@ssw0rd!",
  "nickname": "PlayerOne"
}
```

**Response (201)**

```json
{
  "ok": true,
  "data": {
    "userId": 101
  }
}
```

**Ошибки:**

* `400 VALIDATION_ERROR` (email невалиден, пароль слабый)
* `409 EMAIL_ALREADY_EXISTS`

**Почему 409:** это конфликт уникальности `users.email`.

**Что студент должен обязательно учесть (почему так):**

* пароль хранится **только как hash** (bcrypt/argon2), иначе это критическая уязвимость;
* email должен валидироваться (минимально — формат);
* nickname ограничить по длине, иначе мусор и XSS в UI.

---

### 5.4.2. `POST /login` — получение JWT

**Назначение:** выдать `accessToken`.

**Request**

```http
POST /api/v1/auth/login
Content-Type: application/json
```

```json
{
  "email": "player1@example.com",
  "password": "P@ssw0rd!"
}
```

**Response (200)**

```json
{
  "ok": true,
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIs...",
    "tokenType": "Bearer",
    "expiresInSeconds": 3600
  }
}
```

**Ошибки:**

* `401 INVALID_CREDENTIALS`
* `403 USER_BANNED`

**Почему 403 для ban:** токен может быть валиден, но доступ запрещён политикой.

**Реальный нюанс:**
Если пользователь забанен после выдачи токена — сервер всё равно должен проверять `users.is_banned` на защищённых endpoint’ах (или держать ban-cache).
Иначе бан “не работает” до истечения токена.

---

### 5.4.3. `GET /profile` — профиль игрока

**Назначение:** отдать “витрину” профиля: user + progress (+ опционально достижения/лучшие результаты)

**Request**

```http
GET /api/v1/profile
Authorization: Bearer <JWT>
```

**Response (200)**

```json
{
  "ok": true,
  "data": {
    "user": {
      "id": 101,
      "email": "player1@example.com",
      "nickname": "PlayerOne",
      "createdAt": "2026-02-26T10:00:00.000Z"
    },
    "progress": {
      "level": 6,
      "xp": 2450,
      "softCurrency": 1200,
      "hardCurrency": 10
    }
  }
}
```

**Почему профиль агрегирует несколько таблиц:**
клиенту нужен один запрос “всё для экрана профиля”, а не 5 запросов.

**Архитектурная причина:**
UI профиля должен открываться быстро и детерминированно → сервер отдаёт “витрину”.

---

### 5.4.4. `POST /progress` — обновление прогресса

**Назначение:** обновить агрегированное состояние игрока (level/xp/currency).

**Request**

```http
POST /api/v1/progress
Authorization: Bearer <JWT>
Content-Type: application/json
```

```json
{
  "level": 6,
  "xp": 2450,
  "softCurrency": 1200,
  "hardCurrency": 10,
  "reason": "match_finish"
}
```

**Response (200)**

```json
{
  "ok": true,
  "data": {
    "updatedAt": "2026-02-26T12:18:22.120Z"
  }
}
```

**Ошибки:**

* `400 VALIDATION_ERROR` (level < 1, currency < 0)
* `409 PROGRESS_CONFLICT` (если применяете optimistic lock)

**Почему progress отдельно от event:**
progress — “снимок состояния”, event — “журнал фактов”. Их нельзя смешивать.

**Пояснение “почему так” на примере:**

* событие `currency_change` говорит “почему изменилось”;
* progress говорит “сколько стало сейчас”.
  Оба нужны: аудит экономики + быстрый профиль.

---

### 5.4.5. `POST /event` — отправка события

**Назначение:** фиксировать действия игрока и (опционально) обновлять агрегаты.

**Request**

```http
POST /api/v1/events
Authorization: Bearer <JWT>
Content-Type: application/json
```

```json
{
  "eventType": "match_finish",
  "sessionId": 555,
  "clientTime": "2026-02-26T12:20:10.000Z",
  "payload": {
    "mode": "td",
    "mapCode": "forest_01",
    "season": 1,
    "isWin": true,
    "score": 12450,
    "durationSeconds": 410,
    "waveReached": 12
  }
}
```

**Response (200)**

```json
{
  "ok": true,
  "data": {
    "accepted": true
  }
}
```

**Ошибки:**

* `400 VALIDATION_ERROR` (payload не соответствует схеме)
* `429 RATE_LIMITED`
* `409 EVENT_REJECTED` (например, неконсистентные данные)

**Почему “accepted”:**
в проде часто события пишутся асинхронно/через очередь, и важно различать “принято сервером” vs “отклонено”.

**Дополнение для учебной практики (важно студенту):**

* `userId` берётся только из JWT;
* `createdAt` фиксируется сервером;
* `clientTime` хранить можно, но доверять нельзя.

---

### 5.4.6. `GET /leaderboard` — топ по доске

**Request**

```http
GET /api/v1/leaderboard?boardCode=td_score&season=1&limit=100
Authorization: Bearer <JWT>
```

**Response (200)**

```json
{
  "ok": true,
  "data": {
    "boardCode": "td_score",
    "season": 1,
    "items": [
      { "rank": 1, "userId": 10, "nickname": "Max", "score": 50000 },
      { "rank": 2, "userId": 15, "nickname": "Lina", "score": 45000 }
    ]
  }
}
```

**Почему rank можно считать на сервере:**
клиенту не надо вычислять позицию — это серверная функция и зависит от правил.

**Практический нюанс:**
Если лидерборд большой, rank лучше считать:

* window-функциями (MySQL 8), или
* отдельной логикой “позиции текущего игрока” (отдельный запрос).

---

### 5.4.7. `GET /stats` — статистика игрока

**Request**

```http
GET /api/v1/stats?from=2026-02-01&to=2026-02-26
Authorization: Bearer <JWT>
```

**Response (200)**

```json
{
  "ok": true,
  "data": {
    "from": "2026-02-01",
    "to": "2026-02-26",
    "daily": [
      { "day": "2026-02-25", "sessionsCount": 2, "playtimeSeconds": 1200, "wins": 1, "losses": 0, "scoreSum": 12450 }
    ],
    "summary": {
      "daysActive": 12,
      "playtimeSeconds": 15300,
      "wins": 18,
      "losses": 9
    }
  }
}
```

**Почему summary отдаём сразу:**
чтобы клиент не суммировал сам и не делал лишние запросы.

**Пояснение “почему так” на примере Unity:**
суммирование на клиенте = риск:

* разные платформы считают по-разному (округления, ошибки),
* больше кода в клиенте,
* больше багов.

---

## 5.5. Swagger / OpenAPI (что студент обязан оформить)

### 5.5.1. Что должно быть в OpenAPI

* все endpoints из MVP
* схемы:

  * `RegisterRequest`, `LoginRequest`
  * `EventRequest` (с `eventType` + `payload`)
  * `ErrorResponse`
* SecurityScheme: `bearerAuth`

**Минимальный фрагмент (пример):**

```yaml
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
```

### Пояснение “почему Swagger обязателен”

1. **Это “контракт”**: разработчик клиента и backend работают по одному документу.
2. **Это QA-инструмент**: преподаватель/тестер может прогнать API без чтения кода.
3. **Это дисциплина проектирования**: если студент не может описать endpoint в OpenAPI — значит он сам не понимает контракт.

### Что студент обычно забывает (и это ломает Swagger)

* описать `401/403/409/429` как возможные ответы;
* описать `ErrorResponse` единообразно;
* добавить `security` на защищённые endpoint’ы:

  ```yaml
  security:
    - bearerAuth: []
  ```
