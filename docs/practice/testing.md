# 1. Теория. 7. Тестирование интеграции (клиент ↔ REST API ↔ MySQL) — расширенная версия

Раздел 7 фиксирует инженерный минимум: студент должен уметь доказать, что **интеграция работает воспроизводимо** (по шагам), что **контракт API стабилен**, что **клиент корректно ведёт себя при ошибках**, а база данных **не получает мусор/дубли** при повторных запросах и сетевых сбоях. В отличие от “просто запросы проходят”, тестирование интеграции — это проверка всей цепочки: **Client → HTTP → Backend → MySQL → обратно**.

---

## 7.1. Уровни тестирования: что именно проверяем и чем

### 7.1.1. API-level (Postman / curl) — тестируем API без клиента

Цель: изолировать сервер и контракт.

Проверяем:

* корректные **HTTP-статусы**: `200/201/400/401/403/409/429/500`
* **формат ответа** всегда один и тот же:

  * успех: `{ ok:true, data:{...} }`
  * ошибка: `{ ok:false, error:{ code, message, requestId } }`
* корректность **JWT**:

  * выдаётся на `/auth/login`
  * работает на защищённых методах (например `/profile`, `/events`)
  * инвалидный/битый токен → `401`

Что студент должен показать в отчёте:

* 6–10 скриншотов Postman (Request+Response)
* или `curl` команды + ответы (текстом)

---

### 7.1.2. Client-level (Unity / Web) — тестируем поведение клиента

Цель: доказать, что клиентская интеграция инженерно корректна.

Проверяем:

* добавляется ли `Authorization: Bearer <token>` во **все** защищённые запросы
* сериализация JSON соответствует контракту (нет “сломанных” payload)
* корректные таймауты (не зависает бесконечно)
* унифицированная обработка ошибок (ErrorMapper/единая логика)
* offline-first:

  * события попадают в очередь до отправки
  * при ошибке остаются в очереди
* backoff при `429`:

  * клиент прекращает спамить
  * делает паузу по экспоненте
  * продолжает после задержки

Что студент должен показать:

* логи Unity Console / Web Console
* Network tab (браузер) или логирование клиента (Unity)
* короткий сценарий: “получил 429 → подождал → продолжил”

---

### 7.1.3. DB-level (MySQL) — тестируем целостность данных

Цель: доказать, что backend **правильно пишет** данные и база их защищает.

Проверяем:

* запись появилась в нужной таблице
* FK/UNIQUE/CHECK не нарушаются
* повторные запросы **не создают дубль** (дедуп по eventId)
* user_id в событиях берётся из JWT, а не из body

Что студент должен приложить:

* файл `db/check.sql` (3–10 запросов)
* результаты выполнения (скрин/вывод)

---

## 7.2. Базовый набор тест-данных (reproducible setup)

Чтобы преподаватель мог повторить проверку, студент фиксирует константы:

* user: `player1@example.com`
* password: `P@ssw0rd!` *(только для стенда)*
* boardCode: `td_score`
* season: `1`
* sessionId: `555`
* eventId для дедуп-теста: `c2a4f7be-0f0c-4e69-9f20-93f8c4f50a4d`

Правило: **в отчёте эти значения должны совпадать** с тем, что используется в Postman/клиенте/SQL.

---

## 7.3. Позитивные сценарии (обязательные): строгий порядок

### P1. Регистрация → пользователь создан

**API**

1. `POST /auth/register`
2. ожидаем: `201`, `ok=true`

**Проверяем смысл**

* запись в `users`
* роль `player` назначена (таблица `user_roles`)

**DB-check**

```sql
SELECT id, email, created_at, is_banned
FROM users
WHERE email='player1@example.com';

SELECT ur.user_id, r.name
FROM user_roles ur
JOIN roles r ON r.id=ur.role_id
WHERE ur.user_id = (SELECT id FROM users WHERE email='player1@example.com');
```

---

### P2. Логин → выдан JWT

**API**

1. `POST /auth/login`
2. ожидаем: `200`, `accessToken` присутствует

**Проверяем смысл**

* `last_login_at` обновился
* токен реально работает на защищённых ручках

**DB-check**

```sql
SELECT last_login_at
FROM users
WHERE email='player1@example.com';
```

---

### P3. Профиль → витрина (users + player_progress)

**API**

1. `GET /profile` с `Authorization: Bearer ...`
2. ожидаем: `200`, `ok=true`, присутствуют `user` и `progress`

**Проверяем смысл**

* один запрос отдаёт всё для UI
* данные валидны:

  * `level >= 1`
  * `currency >= 0`

---

### P4. Отправка события session_start → запись в events

**API**

1. `POST /events` с `eventType=session_start` и фиксированным `eventId`
2. ожидаем: `200`, `accepted=true` *(или другой ваш признак успеха в data)*

**Проверяем смысл**

* событие записано
* user_id соответствует токену, а не body

**DB-check**

```sql
SELECT event_type, created_at, payload_json
FROM game_events
WHERE user_id = (SELECT id FROM users WHERE email='player1@example.com')
ORDER BY created_at DESC
LIMIT 5;
```

---

### P5. Лидерборд читается и сортируется

**API**

1. `GET /leaderboard?boardCode=td_score&season=1&limit=10`
2. ожидаем: `200`, `items` отсортированы

**Проверяем смысл**

* `score DESC`
* rank считает сервер, а не клиент

---

## 7.4. Негативные сценарии (обязательные): не “поймать ошибку”, а доказать политику

### N1. Невалидные данные → 400 VALIDATION_ERROR

**API**

* `POST /progress` с `level=0` или `softCurrency=-1`

**Ожидание**

* `400`
* `ok=false`
* `error.code=VALIDATION_ERROR`
* `requestId` есть

**Плюс DB-проверка**

* в БД не появилось изменений прогресса (или не создана запись)

---

### N2. Нет токена → 401 UNAUTHORIZED

**API**

* `GET /profile` без Authorization

**Ожидание**

* `401`
* единый JSON ошибки

---

### N3. Битый токен → 401 UNAUTHORIZED

**API**

* подменить символ в JWT
* вызвать `GET /profile`

**Ожидание**

* `401`
* на клиенте: logout (очистка токена + переход на login)

---

### N4. Забаненный пользователь → 403 USER_BANNED

**Подготовка**

```sql
UPDATE users SET is_banned=1 WHERE email='player1@example.com';
```

**API**

* `GET /profile` с валидным JWT

**Ожидание**

* `403`, `error.code=USER_BANNED` (или аналог)
* клиент:

  * показывает “доступ запрещён”
  * останавливает EventQueue

*(После теста бан надо снять, чтобы продолжать проверки.)*

---

### N5. Конфликт состояния → 409

**Примеры, которые допустимы в учебном проекте**

* повторное закрытие одной сессии
* повторная “выдача награды” за один матч
* конфликт snapshot-прогресса (optimistic lock)

**Ожидание**

* `409`
* `error.code` осмысленный (`MATCH_ALREADY_FINISHED`, `PROGRESS_CONFLICT`, …)
* клиент: делает refresh (`GET /profile`) или сообщает “состояние изменилось”

---

## 7.5. Проверка авторизации (JWT + RBAC)

### A1. Роль player не может вызывать admin endpoint

**API**

* вызвать `/admin/ban` токеном player

**Ожидание**

* `403 FORBIDDEN`
* контракт ошибки соблюдён

---

### A2. Роль moderator может

**Подготовка**

```sql
INSERT IGNORE INTO roles(name) VALUES ('moderator');

INSERT INTO user_roles(user_id, role_id)
SELECT u.id, r.id
FROM users u, roles r
WHERE u.email='player1@example.com' AND r.name='moderator';
```

**Важно**

* перелогиниться (JWT должен содержать роль)

**Ожидание**

* доступ разрешён (`200`)

**Смысл теста**
RBAC — только серверная политика; клиент не “решает”, кто админ.

---

## 7.6. Проверка 429 Too Many Requests + backoff на клиенте

### R1. Получить 429 на стенде

**Postman Runner / скрипт**

* 30–100 запросов `/events` подряд

**Ожидание**

* начиная с некоторого момента: `429 RATE_LIMITED`

### R2. Клиентское поведение

**Ожидание на клиенте**

* прекращает отправку
* увеличивает задержку: 2s → 4s → 8s → …
* события остаются в очереди и не теряются

**Артефакт зачёта**
лог/видео: видно получение 429 и дальнейшее ожидание.

---

## 7.7. Дедупликация по eventId (критичный тест)

### D1. Два одинаковых запроса с одним eventId

**Шаг**

* два раза `POST /events` с одинаковым `eventId`

**Ожидание (правильно)**

* в БД 1 запись (или вторая “признана дублем” без побочных эффектов)
* сервер не начисляет награду/очки повторно

**DB-check (вариант 1: eventId в JSON)**

```sql
SELECT COUNT(*)
FROM game_events
WHERE payload_json->>'$.eventId' = 'c2a4f7be-0f0c-4e69-9f20-93f8c4f50a4d';
```

**DB-check (лучший вариант: отдельная колонка)**

```sql
SELECT COUNT(*)
FROM game_events
WHERE event_id='c2a4f7be-0f0c-4e69-9f20-93f8c4f50a4d';
```

---

## 7.8. Проверка целостности данных (FK/UNIQUE/CHECK)

### I1. Нельзя “подсунуть” userId в body

**Тест**

* отправить `POST /events` с `payload.userId=999999`

**Ожидание**

* в БД всё равно user_id = из JWT
* значения из payload не влияют на owner события

---

### I2. UNIQUE email

**Тест**

* повторно `POST /auth/register` тем же email

**Ожидание**

* `409 EMAIL_ALREADY_EXISTS` (или ваш код)
* запись не дублируется

---

### I3. CHECK/валидация прогресса

**Тест**

* `POST /progress` с отрицательными значениями

**Ожидание**

* сервер возвращает `400` (валидация на API-уровне)
* в БД не появляются “абсурдные” данные

---

## 7.9. Базовое нагрузочное тестирование (минимум для практики)

### Цель

Не “сломать сервер”, а проверить:

* стабильность контрактов на потоке
* деградацию latency
* отсутствие дублей/гонок

### Минимальный сценарий

* 1000 событий `POST /events`
* параллельность 5–20 (по стенду)

Что студент фиксирует в отчёте:

* p50/p95 latency (можно приблизительно: “обычно 30–80ms, p95 200ms”)
* процент 5xx
* процент 429
* число записей в `game_events` совпадает с количеством **принятых** событий (минус дубль-тест)

---

 