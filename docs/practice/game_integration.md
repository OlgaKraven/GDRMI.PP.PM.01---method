## 6. Интеграция с игрой (Unity / Web / Mobile) — подробная теория и задание

Раздел интеграции проверяет, что студент умеет связать игровой клиент с backend **как инженер**, а не “как набор запросов”. В практике это означает: есть единый сетевой слой, токены живут централизованно, ответы парсятся по контракту, ошибки обрабатываются одинаково, события не теряются, а повторная отправка не ломает данные.

---

# 6.1. Что интегрируем: MVP-сценарии и зачем они именно такие

Минимальный рабочий набор сценариев (MVP) должен закрывать полный цикл данных:

1. **Регистрация/логин** → клиент получает JWT → появляется авторизованный контекст
2. **Профиль** → клиент получает витрину состояния игрока (`user + progress`)
3. **События (телеметрия)** → клиент отправляет “факты” (`session_start`, `match_finish`)
4. **Прогресс** (опционально) → если система хранит snapshot отдельно (`POST /progress`)
5. **Статистика / лидерборд** → клиент читает агрегированные витрины (`/stats`, `/leaderboard`)
6. **Ошибки/лимиты/бан** → клиент умеет корректно жить при 400/401/403/409/429/500

Почему именно эти шаги считаются “архитектурным минимумом”:

* **JWT** проверяет, что студент понимает авторизацию (а не “поставил пароль в query”).
* **Profile** проверяет чтение витрины и работу с DTO.
* **Events** проверяет журналирование фактов и устойчивость к сетевым сбоям.
* **Leaderboard/Stats** проверяет, что студент понимает разницу “сырьё” vs “агрегаты”.
* **Ошибки** проверяют реальную эксплуатацию (в проде 50% багов — это обработка краёв).

---

# 6.2. Архитектура сетевого слоя клиента: как должно быть устроено

## 6.2.1. Почему нельзя “fetch() в кнопке / UnityWebRequest в MonoBehaviour напрямую”

Если запросы “размазаны” по UI:

* токен в одном запросе забудут добавить;
* ошибки будут по-разному обработаны;
* невозможно централизованно включить таймауты/ретраи/логирование;
* сложно тестировать и демонстрировать.

В практике студент обязан показать **минимальную архитектуру клиентского networking слоя**.

## 6.2.2. Минимальные компоненты (обязательные)

### 1) ApiClient (Networking Gateway)

Отвечает только за:

* сбор URL
* добавление заголовков (`Authorization`, `Content-Type`)
* таймаут
* отправку запроса
* парсинг ответа в единый формат (`ApiResponse<T>`)
* возврат результата в бизнес-слой

**ApiClient не должен знать UI**, не должен хранить состояние игрока кроме токена.

---

### 2) TokenStore (JWT storage + lifecycle)

Отвечает за:

* сохранение токена
* загрузку токена при старте клиента
* очистку токена (logout)
* (опционально) проверку срока жизни / refresh flow

Где хранить:

* Unity: PlayerPrefs (в учебной работе допустимо) / secure storage (как “правильно”)
* Web: memory (лучше для security) / localStorage (в учебном MVP допустимо)

---

### 3) EventQueue (Offline-first)

Отвечает за:

* добавление события в очередь **до отправки**
* отправку из очереди (по одному или пачкой)
* удаление из очереди только при подтверждённом успехе
* сохранение очереди (минимум: JSON-файл/PlayerPrefs; лучше: SQLite)

---

### 4) ErrorMapper (policy layer)

Отвечает за:

* перевод `error.code` и HTTP статусов в действия:

  * “logout”
  * “backoff”
  * “retry”
  * “show message”
* единый UX для ошибок

---

# 6.3. Контракт HTTP/JSON: что обязан соблюдать клиент и сервер

## 6.3.1. Единый формат ответа

Чтобы клиент всегда понимал, что парсить, в системе вводится контракт:

**Успех:**

```json
{ "ok": true, "data": { } }
```

**Ошибка:**

```json
{
  "ok": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Field level must be >= 1",
    "requestId": "req_01HF..."
  }
}
```

### Почему `requestId` обязателен

`requestId` — это связка клиент ↔ лог сервера:

* студент фиксирует requestId в отчёте/консоли
* преподаватель находит соответствующую запись в логах backend
* локализация причины ускоряется в разы

---

## 6.3.2. События и прогресс — это разные сущности (это принцип!)

* `/events` — журнал фактов (история): “что случилось”
* `/progress` — состояние (snapshot): “что сейчас”

Если смешать:

* “прогресс как событие” → всё нужно пересчитывать из логов
* “события как прогресс” → теряется история и аудит

---

## 6.3.3. Дедупликация: `eventId` как защита от повторов

Мобильная сеть = повтор отправки почти неизбежен.
Поэтому:

* каждое событие имеет `eventId` (UUID)
* сервер делает дедуп по eventId (уникальный индекс)

Это защищает от:

* двойной валюты
* двойного начисления наград
* разъезжающихся статистик

---

# 6.4. Unity интеграция: инженерный минимум

## 6.4.1. Почему JsonUtility часто не подходит

`JsonUtility` плохо работает с:

* `Dictionary`
* универсальным `payload` типа object
* массивами сложных типов
* вложенными динамическими структурами

Поэтому в учебной работе **нормально** использовать Newtonsoft.Json.

---

## 6.4.2. DTO (data transfer objects): что и зачем

DTO нужны, чтобы:

* разорвать связь UI ↔ JSON
* обеспечить типизацию
* сделать предсказуемый контракт

Минимальный набор DTO:

* `ApiResponse<T>`
* `ApiError`
* `LoginRequest`, `LoginData`
* `ProfileData` (user + progress)
* `EventRequest<TPayload>`

---

## 6.4.3. Логирование сетевого слоя (обязательно)

На каждую операцию клиент должен логировать:

* метод + path
* HTTP status
* длительность
* requestId (если есть)
* код ошибки (если есть)

Это не “доп”, это эксплуатационная необходимость.

---

# 6.5. Web интеграция: инженерный минимум

## 6.5.1. Timeout и зависания

В браузере fetch может висеть долго. Поэтому нужен:

* `AbortController`
* `timeoutMs`

Иначе UX “сломается”, а студент не покажет устойчивость.

---

## 6.5.2. Единый apiFetch

Функция `apiFetch` должна:

* добавлять `Authorization`
* парсить JSON
* проверять `res.ok` и `json.ok`
* выбрасывать структурированную ошибку

---

# 6.6. Mobile-специфика: обязательные знания

## 6.6.1. Offline-first для событий

Правило: **события не теряем**.
Если нет сети:

* кладём событие в очередь
* отправляем при восстановлении

Это базовая инженерная зрелость для игр.

## 6.6.2. Backoff на 429

Если прилетает rate limit:

* нельзя спамить повтором
* включаем экспоненциальную задержку:

  * 1 → 2 → 4 → 8 → … (до 30 сек)

---

# 6.7. EventQueue: минимальная реализация логики (что должен уметь студент)

Очередь обязана реализовать политику:

1. сформировать событие (UUID + payload)
2. положить в очередь
3. попытаться отправить
4. при успехе удалить
5. при 401/403 остановить очередь + logout
6. при 429 backoff
7. при network error оставить в очереди

---

# 6.8. Таблица “ошибка → действие клиента” (обязательна в отчёте)

| Ситуация           | HTTP / code            | Действие клиента                                              |
| ------------------ | ---------------------- | ------------------------------------------------------------- |
| Данные невалидны   | 400 / VALIDATION_ERROR | показать сообщение, логировать requestId                      |
| Нет токена/истёк   | 401 / UNAUTHORIZED     | logout + экран login                                          |
| Бан пользователя   | 403 / USER_BANNED      | показать “доступ запрещён”, остановить очередь                |
| Конфликт состояния | 409                    | обновить профиль (GET /profile), показать “данные изменились” |
| Слишком часто      | 429 / RATE_LIMITED     | backoff, блокировать повтор                                   |
| Ошибка сервера     | 500                    | показать “позже”, логировать requestId                        |

---

# ✅ Практическое задание (подробно)

## Вариант A: Unity (рекомендуется для геймдева)

**Сделать:**

1. Экран Login (email+password)
2. `POST /auth/login` → сохранить JWT в TokenStore
3. Экран Profile (nickname + level + currency)
4. `GET /profile` с JWT
5. Кнопка “Send session_start”
6. `POST /events` с UUID
7. Ошибки:

   * `401` → очистить токен, вернуть на login
   * `429` → backoff + повтор через задержку
   * network → сохранить в очередь и показать “будет отправлено позже”

**Артефакты:**

* код (`ApiClient.cs`, `TokenStore.cs`, `EventQueue.cs`)
* видео/скрины из Unity Console + результат UI
* README со сценарием проверки

---

## Вариант B: Web (быстрее для проверки)

**Сделать:**

1. HTML форма login
2. `apiFetch("/auth/login")` → сохранить токен
3. кнопка “Load profile” → `GET /profile`
4. кнопка “Send session_start” → `POST /events` UUID
5. обработка 401/429 как в таблице
6. вывод ошибок на экран (не только console)

**Артефакты:**

* исходники (`api.js`, `auth.js`, `events.js`)
* скрин DevTools Network (login, profile, events)
* README

---
 